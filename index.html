<!-- PART 1/5 START -->
<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Oz Ninja</title>

<style>
  html,body{
    margin:0;width:100%;height:100%;overflow:hidden;background:#0f0f12;
    font-family:system-ui,-apple-system,Segoe UI,Roboto;
    touch-action:manipulation;-webkit-user-select:none;user-select:none;
  }
  :root{
    --pad-top: env(safe-area-inset-top);
    --pad-right: env(safe-area-inset-right);
    --pad-bottom: env(safe-area-inset-bottom);
    --pad-left: env(safe-area-inset-left);
    --wood1:#a56a3c; --wood2:#7a4b2a; --ink:#22140b; --accent:#ff7a18;
    --paper1:#f7edd6; --paper2:#f0e0bf;
  }
  *{-webkit-tap-highlight-color:transparent}
  .hidden{display:none!important}

  /* ===== Top bar ===== */
  #topbar{
    position:absolute; z-index:50;
    left:calc(10px + var(--pad-left));
    right:calc(10px + var(--pad-right));
    top:calc(10px + var(--pad-top));
    display:flex;gap:8px;align-items:center;justify-content:space-between;
    background:linear-gradient(var(--wood1),var(--wood2));
    border:2px solid rgba(0,0,0,.18);
    border-radius:14px;
    padding:8px 10px;
    box-shadow:0 10px 24px rgba(0,0,0,.25);
    color:var(--ink);
  }
  .barL,.barR{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .chip{
    display:flex;gap:6px;align-items:center;
    background:rgba(255,255,255,.22);
    border:1px solid rgba(0,0,0,.14);
    border-radius:999px;
    padding:5px 8px;
    font-weight:950;
    font-size:11px;
    line-height:1;
  }
  .chip b{font-family:ui-monospace,Menlo,monospace}
  .btn{
    border:0;border-radius:12px;padding:9px 10px;font-weight:950;
    background:#eee;color:#111; box-shadow:0 6px 14px rgba(0,0,0,.18);
    font-size:12px;
  }
  .btn.primary{background:var(--accent)}
  .btn.ghost{background:rgba(255,255,255,.25); border:1px solid rgba(0,0,0,.14);}
  .btn.small{padding:7px 9px;font-size:11px;border-radius:11px}
  .btn:disabled{opacity:.55}

  /* ===== Town ===== */
  #town{ position:absolute; inset:0; padding-top:calc(56px + var(--pad-top)); }
  #townLayer{ position:absolute; inset:0; transform: translateY(95px); }
  #townBg{
    position:absolute; inset:0;
    background-image:url("town.jpg");
    background-size:cover;
    background-position:center top;
    background-repeat:no-repeat;
  }
  .hotspot{ position:absolute; background:transparent; border:0; border-radius:18px; padding:0; z-index:10; }
  .label{
    position:absolute; left:50%; bottom:10%;
    transform:translateX(-50%);
    padding:8px 12px;
    border-radius:999px;
    background:rgba(255,255,255,.78);
    border:1px solid rgba(0,0,0,.15);
    font-weight:1000;
    font-size:14px;
    color:#111;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    pointer-events:none;
    white-space:nowrap;
  }

  /* Hotspots */
  #hsHospital { left:  2%; top: 11%; width: 38%; height: 22%; }
  #hsDojo     { left: 66%; top: 10%; width: 32%; height: 26%; }
  #hsDaimyo   { left: 33%; top: 26%; width: 36%; height: 22%; }
  #hsRelic    { left:  4%; top: 40%; width: 32%; height: 20%; }
  #hsWeapon   { left: 62%; top: 33%; width: 34%; height: 22%; }
  #hsRecruit  { left:  6%; top: 60%; width: 36%; height: 22%; }
  #hsFight    { left: 49%; top: 51%; width: 47%; height: 22%; }

  /* ===== Modals ===== */
  .modal{
    position:absolute; inset:0; z-index:80;
    display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.35);
    padding:14px;
  }
  .card{
    width:min(760px,96%);
    background:linear-gradient(var(--paper1),var(--paper2));
    border:2px solid rgba(0,0,0,.18);
    border-radius:18px;
    padding:14px;
    box-shadow:0 20px 50px rgba(0,0,0,.28);
    color:#23140b;
  }
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .sp{justify-content:space-between}
  .title{margin:0;font-size:16px;font-weight:1000}
  .muted{opacity:.78;font-size:12px;line-height:1.25}
  .statGrid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:10px}
  .stat{
    background:rgba(255,255,255,.35);
    border:1px solid rgba(0,0,0,.12);
    border-radius:14px;
    padding:10px 12px;
    font-size:12px;
  }
  .stat b{font-family:ui-monospace,Menlo,monospace;font-size:13px}
  .list{
    margin-top:10px;
    max-height:340px; overflow:auto;
    border-radius:14px;
    border:1px solid rgba(0,0,0,.14);
    background:rgba(255,255,255,.22);
  }
  .item{
    display:flex;align-items:center;justify-content:space-between;gap:10px;
    padding:10px 12px;border-bottom:1px solid rgba(0,0,0,.10);
    font-size:12px;
  }
  .item:last-child{border-bottom:0}
  .pill{
    display:inline-block;
    padding:4px 8px;border-radius:999px;
    background:rgba(255,255,255,.55);
    border:1px solid rgba(0,0,0,.10);
    font-size:11px;font-weight:950;
  }
  .rar{font-weight:1000}
  .rar.Common{color:#555}
  .rar.Uncommon{color:#0d7a1c}
  .rar.Rare{color:#1a63c8}
  .rar.Epic{color:#7a2ac9}
  .rar.Legendary{color:#b06b00}
  .rar.Mythic{color:#d43cff}

  /* Tabs */
  .tabs{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  .tab{
    padding:8px 10px;border-radius:999px;font-weight:1000;font-size:12px;
    border:1px solid rgba(0,0,0,.14);
    background:rgba(255,255,255,.35);
  }
  .tab.active{background:rgba(255,255,255,.65)}
  .tabPane{margin-top:10px}

  /* Dojo preview */
  #dojoPreviewWrap{
    display:flex;gap:12px;align-items:center;flex-wrap:wrap;
    background:rgba(255,255,255,.22);
    border:1px solid rgba(0,0,0,.12);
    border-radius:14px;
    padding:10px 12px;
    margin-top:10px;
  }
  #dojoCanvas{
    width:140px;height:140px;
    border-radius:14px;
    border:1px solid rgba(0,0,0,.12);
    background:rgba(0,0,0,.08);
  }

  /* Battle scene */
  #battle{ position:absolute; inset:0; z-index:60; }
  #battleBg{
    position:absolute; inset:0;
    background-image:url("battle.jpg");
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    transform:scale(1.02);
  }
  #battleHud{
    position:absolute; left:0; right:0; top:0;
    padding:calc(10px + var(--pad-top)) calc(10px + var(--pad-right)) 10px calc(10px + var(--pad-left));
    z-index:70;
    display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
  }
  #battleHud .panel{
    background:rgba(255,255,255,.85);
    border:2px solid rgba(0,0,0,.16);
    border-radius:14px;
    padding:8px 10px;
    box-shadow:0 14px 34px rgba(0,0,0,.18);
    color:#1d120b;
    font-weight:950;
    font-size:12px;
  }
  #battleStageWrap{
    position:absolute; inset:0;
    padding-top:calc(70px + var(--pad-top));
    padding-bottom:calc(16px + var(--pad-bottom));
    z-index:65;
    display:flex; align-items:center; justify-content:center;
  }
  #battleCanvas{
    width:min(960px,96vw);
    height:min(560px,62vh);
    border-radius:18px;
    border:2px solid rgba(255,255,255,.10);
    background:rgba(0,0,0,.16);
    box-shadow:0 20px 60px rgba(0,0,0,.35);
  }
  #battleLog{
  position:absolute;
  left:calc(10px + var(--pad-left));
  right:calc(10px + var(--pad-right));
  bottom:calc(10px + var(--pad-bottom));
  z-index:75;

  /* â†“â†“â†“ CHANGES â†“â†“â†“ */
  max-height: 90px;          /* about half current size */
  overflow-y: auto;           /* scroll if log grows */
  background: rgba(255,255,255,.45); /* more transparent */

  border:2px solid rgba(0,0,0,.16);
  border-radius:14px;
  padding:8px 10px;
  font-size:12px;
  color:#1d120b;
  box-shadow:0 14px 34px rgba(0,0,0,.18);
}
  #battleLog .muted{font-size:11px}
  #battleText{white-space: pre-line;}
  #battleLogButtons{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
</style>
</head>

<body>
  <div id="topbar">
    <div class="barL">
      <div class="chip">Build <b>FULL</b></div>
      <div class="chip">Active <b id="uiName">â€”</b></div>
      <div class="chip">Lv <b id="uiLevel">â€”</b></div>
      <div class="chip">HP <b id="uiHP">â€”</b></div>
      <div class="chip">TP <b id="uiTP">â€”</b></div>
      <div class="chip">Belt <b id="uiBelt">â€”</b></div>
      <div class="chip">ðŸª™ <b id="uiGold">0</b></div>
      <div class="chip">â˜¯ <b id="uiKarma">0</b></div>
    </div>
    <div class="barR">
      <button class="btn ghost small" id="dailyBtn">Meditate</button>
      <button class="btn ghost small" id="profilesBtn">Profiles</button>
      <button class="btn ghost small" id="saveBtn">Save</button>
      <button class="btn ghost small" id="resetBtn">Reset Slot</button>
    </div>
  </div>

  <!-- Town -->
  <div id="town">
    <div id="townLayer">
      <div id="townBg"></div>
      <button class="hotspot" id="hsHospital"><div class="label">Hospital</div></button>
      <button class="hotspot" id="hsDojo"><div class="label">Dojo</div></button>
      <button class="hotspot" id="hsDaimyo"><div class="label">Daimyo</div></button>
      <button class="hotspot" id="hsRelic"><div class="label">Relic Shop</div></button>
      <button class="hotspot" id="hsWeapon"><div class="label">Weapon Shop</div></button>
      <button class="hotspot" id="hsRecruit"><div class="label">Recruit</div></button>
      <button class="hotspot" id="hsFight"><div class="label">Battle</div></button>
    </div>
  </div>

  <!-- Battle -->
  <div id="battle" class="hidden">
    <div id="battleBg"></div>
    <div id="battleHud">
      <div class="panel" id="bhLeft">â€”</div>
      <div class="panel" id="bhMid">â€”</div>
      <div class="panel" id="bhRight">â€”</div>
    </div>
    <div id="battleStageWrap">
      <canvas id="battleCanvas" width="960" height="560"></canvas>
    </div>
    <div id="battleLog">
      <div style="font-weight:1000" id="battleTitle">Battle</div>
      <div class="muted" id="battleSub">â€”</div>
      <div id="battleText" style="margin-top:6px">â€”</div>
      <div id="battleLogButtons">
        <button class="btn primary" id="battleNextBtn">Next</button>
        <button class="btn" id="battleAutoBtn">Auto</button>
        <button class="btn ghost" id="battleRetreatBtn">Retreat</button>
      </div>
    </div>
  </div>

  <!-- Dojo Modal -->
  <div class="modal hidden" id="dojoModal">
    <div class="card">
      <div class="row sp">
        <h3 class="title">Dojo</h3>
        <button class="btn ghost small" id="closeDojo">Close</button>
      </div>

      <div class="tabs">
        <button class="tab active" id="tabTrain">Training</button>
        <button class="tab" id="tabNinja">Ninja</button>
      </div>

      <div class="tabPane" id="paneTrain">
        <div class="muted">Belt + Level are tied to <b>TP spent</b>. Training has soft caps.</div>

        <div class="statGrid">
          <div class="stat">Strength<br><b id="stSTR">1</b><div class="muted">Cost: <b id="cSTR">1</b> TP</div></div>
          <div class="stat">Agility<br><b id="stAGI">1</b><div class="muted">Cost: <b id="cAGI">1</b> TP</div></div>
          <div class="stat">Endurance<br><b id="stEND">1</b><div class="muted">Cost: <b id="cEND">1</b> TP</div></div>
        </div>

        <div class="row" style="margin-top:10px">
          <button class="btn primary" id="trainSTR">+ STR</button>
          <button class="btn primary" id="trainAGI">+ AGI</button>
          <button class="btn primary" id="trainEND">+ END</button>
        </div>

        <div class="muted" style="margin-top:10px">
          TP: <b id="tpHere">0</b> â€¢ Active: <b id="activeHere">â€”</b>
        </div>
      </div>

      <div class="tabPane hidden" id="paneNinja">
        <div class="muted">Equip weapons/relics you own. Weapons have unique looks and bonuses.</div>

        <div id="dojoPreviewWrap">
          <canvas id="dojoCanvas" width="140" height="140"></canvas>
          <div style="min-width:220px;flex:1">
            <div style="font-weight:1000;font-size:14px" id="djName">â€”</div>
            <div class="muted" id="djLine">â€”</div>
            <div class="muted" id="djBelt">â€”</div>
          </div>
        </div>

        <div class="statGrid">
          <div class="stat">Base STR/AGI/END<br><b id="djBase">â€”</b></div>
          <div class="stat">Equip Bonus<br><b id="djBonus">â€”</b></div>
          <div class="stat">Derived ATK/DEF/DODGE<br><b id="djDerived">â€”</b></div>
        </div>

        <div class="row" style="margin-top:10px;align-items:flex-end">
          <div style="flex:1;min-width:220px">
            <div class="muted" style="margin-bottom:6px">Weapon (owned)</div>
            <select id="djWeaponSelect" style="width:100%;padding:10px;border-radius:12px;border:1px solid rgba(0,0,0,.18)">
              <option value="">None</option>
            </select>
          </div>
          <button class="btn primary" id="djEquipWeapon">Equip</button>
          <button class="btn ghost" id="djUnequipWeapon">Unequip</button>
        </div>

        <div class="row" style="margin-top:10px;align-items:flex-end">
          <div style="flex:1;min-width:220px">
            <div class="muted" style="margin-bottom:6px">Relic (owned)</div>
            <select id="djRelicSelect" style="width:100%;padding:10px;border-radius:12px;border:1px solid rgba(0,0,0,.18)">
              <option value="">None</option>
            </select>
          </div>
          <button class="btn primary" id="djEquipRelic">Equip</button>
          <button class="btn ghost" id="djUnequipRelic">Unequip</button>
        </div>

        <div class="muted" style="margin-top:10px">
          Equipped: <b id="djEquipped">â€”</b>
        </div>
      </div>
    </div>
  </div>

  <!-- Daimyo Modal -->
  <div class="modal hidden" id="daiModal">
    <div class="card">
      <div class="row sp">
        <h3 class="title">Daimyo</h3>
        <button class="btn ghost small" id="closeDai">Close</button>
      </div>
      <div class="muted">Belt thresholds (by TP spent): Yellow 5 â€¢ Orange 12 â€¢ Green 20 â€¢ Blue 40 â€¢ Brown 60 â€¢ Black 80</div>

      <div class="statGrid">
        <div class="stat">Belt<br><b id="dBelt">â€”</b></div>
        <div class="stat">Level<br><b id="dLevel">â€”</b></div>
        <div class="stat">TP Spent<br><b id="dSpent">â€”</b></div>
      </div>
    </div>
  </div>

  <!-- Recruit Modal -->
  <div class="modal hidden" id="recruitModal">
    <div class="card">
      <div class="row sp">
        <h3 class="title">Recruit</h3>
        <button class="btn ghost small" id="closeRecruit">Close</button>
      </div>

      <div class="muted">Recruit ninjas to grow your clan. In battles, <b>your whole clan fights</b> (one at a time) so having more ninjas is an advantage.</div>

      <div class="row" style="margin-top:10px">
        <button class="btn primary" id="recruitBtn">Recruit (ðŸª™ <span id="recruitCost">200</span>)</button>
        <button class="btn ghost" id="setActiveBtn">Set Selected Active</button>
      </div>

      <div class="list" id="rosterList"></div>
    </div>
  </div>

  <!-- Weapon Shop Modal -->
  <div class="modal hidden" id="weaponModal">
    <div class="card">
      <div class="row sp">
        <h3 class="title">Weapon Shop</h3>
        <button class="btn ghost small" id="closeWeapon">Close</button>
      </div>

      <div class="muted">Weapons all have different stats. More stats = higher gold cost. Best weapon gives <b>+25 STR +25 AGI +5 END</b>.</div>

      <div class="row" style="margin-top:10px">
        <button class="btn ghost" id="buyWeaponBtn">Buy Selected</button>
        <button class="btn primary" id="equipWeaponBtn">Equip Selected</button>
        <button class="btn ghost" id="refreshWeaponBtn">Refresh</button>
      </div>

      <div class="list" id="weaponList"></div>
    </div>
  </div>

  <!-- Relic Shop Modal -->
  <div class="modal hidden" id="relicModal">
    <div class="card">
      <div class="row sp">
        <h3 class="title">Relic Shop</h3>
        <button class="btn ghost small" id="closeRelic">Close</button>
      </div>

      <div class="muted">Relics cost â˜¯ karma. Smaller bonuses that stack with weapons.</div>

      <div class="row" style="margin-top:10px">
        <button class="btn ghost" id="buyRelicBtn">Buy Selected</button>
        <button class="btn primary" id="equipRelicBtn">Equip Selected</button>
        <button class="btn ghost" id="refreshRelicBtn">Refresh</button>
      </div>

      <div class="list" id="relicList"></div>
    </div>
  </div>

  <!-- Battle Select Modal -->
  <div class="modal hidden" id="battleSelectModal">
    <div class="card">
      <div class="row sp">
        <h3 class="title">Choose Battle</h3>
        <button class="btn ghost small" id="closeBattleSelect">Close</button>
      </div>
      <div class="muted">Select an enemy clan. Enemy clan sizes vary. Boss battle is always a single max-level black belt ninja.</div>
      <div class="list" id="battleList"></div>
    </div>
  </div>

  <!-- Profiles Modal -->
  <div class="modal hidden" id="profilesModal">
    <div class="card">
      <div class="row sp">
        <h3 class="title">Profiles</h3>
        <button class="btn ghost small" id="closeProfiles">Close</button>
      </div>
      <div class="muted">3 save slots. You can view other slots (read-only summary) and load them.</div>
      <div class="list" id="profilesList"></div>
    </div>
  </div>

  <script>
/* ======================================================
   NINJA CLAN RPG â€” FULL SINGLE-FILE GAME
   Paste-safe: delivered in 5 parts.
====================================================== */

const PROFILE_KEY="ninja_clan_full_v1";

/* ---------- Utils ---------- */
const $ = (id)=>document.getElementById(id);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rand=(a,b)=>a+Math.random()*(b-a);
const rint=(a,b)=>Math.floor(rand(a,b+1));
const pick=a=>a[Math.floor(Math.random()*a.length)];
const uid=(p)=>`${p}_${Math.random().toString(16).slice(2)}_${Date.now().toString(16)}`;
const nowMs=()=>Date.now();

/* (more JS continues in Part 2) */
/* ---------- Belt system (TP spent) ---------- */
const BELTS=["White","Yellow","Orange","Green","Blue","Brown","Black"];
const BELT_TP={White:0,Yellow:5,Orange:12,Green:20,Blue:40,Brown:60,Black:80};
const BELT_COLOR={
  White:"#f5f5f5",Yellow:"#ffd54a",Orange:"#ff8a2a",Green:"#37c76b",
  Blue:"#3a82ff",Brown:"#7a4b2a",Black:"#111111"
};
function tpSpent(n){ return (n.base.str-1)+(n.base.agi-1)+(n.base.end-1); }
function beltFromSpent(spent){
  let b="White";
  for(const name of BELTS) if(spent>=BELT_TP[name]) b=name;
  return b;
}
const LEVEL_CAP = 120;               // <- max level you want
const MAX_SPENT_FOR_LEVEL = LEVEL_CAP - 1;
    function isLevelCapped(n){
  return tpSpent(n) >= MAX_SPENT_FOR_LEVEL; // at 119 spent => level 120
}
/* ---------- Training soft caps ---------- */
function trainCost(statVal){
  if(statVal>=60) return 50;
  if(statVal>=51) return 15;
  if(statVal>=41) return 10;
  if(statVal>=31) return 6;
  if(statVal>=21) return 5;
  if(statVal>=16) return 4;
  if(statVal>=11) return 3;
  if(statVal>=6) return 2;
  return 1;
}

/* ---------- Weapons: distinct stats + cost scaling ----------
   Best: +25 STR +25 AGI +5 END (Legendary)
   Goes down from there with cost
----------------------------------------------------------- */
const WEAPON_TIERS=[
  {rar:"Common",    str:2,  agi:1,  end:0, cost:60},
  {rar:"Uncommon",  str:4,  agi:3,  end:1, cost:140},
  {rar:"Rare",      str:7,  agi:6,  end:2, cost:320},
  {rar:"Epic",      str:10, agi:10, end:3, cost:650},
  {rar:"Legendary", str:15, agi:15, end:5, cost:1200},
];

const WEAPON_CATALOG=[
  {name:"Katana",      art:"katana"},
  {name:"Tanto",       art:"tanto"},
  {name:"Naginata",    art:"naginata"},
  {name:"War Fan",     art:"fan"},
  {name:"Iron Staff",  art:"staff"},
  {name:"Moon Blade",  art:"moon"},
  {name:"Storm Edge",  art:"storm"},
  {name:"Kunai Chain", art:"chain"},
  {name:"Dragon Dagger", art:"dragonDagger"},
];

const RELIC_CATALOG=[
  "Focus Charm","Shadow Bead","Lotus Token","Phoenix Feather","Smoke Ring","Karma Bead",
  "River Stone","Silent Bell","Old Coin","Wind Talisman"
];

function makeWeapon(){
  const t=WEAPON_TIERS[rint(0,WEAPON_TIERS.length-1)];
  const base=pick(WEAPON_CATALOG);
  // Slight variability while keeping tier identity (still "all different")
  const wiggle = (v, maxDown=0, maxUp=0)=> clamp(v + rint(-maxDown, maxUp), 0, 99);
  const bonus={
    str: wiggle(t.str, 1, 1),
    agi: wiggle(t.agi, 1, 1),
    end: wiggle(t.end, 0, 1),
  };
  // cost rises with total stats (keeps "more stats cost more gold")
  const power = bonus.str*2 + bonus.agi*2 + bonus.end*3;
  const cost  = Math.max(t.cost, 40 + power*18);
  return {
    id:uid("w"),
    type:"weapon",
    rarity:t.rar,
    name:base.name,
    art:base.art,
    bonus,
    cost
  };
}

function makeRelic(){
  const bonus={str:rint(0,2), agi:rint(0,3), end:rint(0,3)};
  const power = bonus.str*2 + bonus.agi*2 + bonus.end*2;
  const cost  = 60 + power*35;
  const rarity = power>=14?"Epic":power>=10?"Rare":power>=7?"Uncommon":"Common";
  return {id:uid("r"), type:"relic", rarity, name:pick(RELIC_CATALOG), bonus, cost};
}

/* ---------- Save data ---------- */
function makeNinja(name=null){
  const first=["Ryu","Hana","Jin","Kira","Sora","Mako","Taro","Yumi","Akio","Ren","Aya","Kai","Noa","Rin"];
  const last=["Shadow","Steel","Blaze","Mist","Fang","Lotus","Night","Storm","Viper","Drift"];
  const nm=name||`${pick(first)} ${pick(last)}`;
  return {
    id:uid("n"),
    name:nm,
    tp:0,
    base:{str:1,agi:1,end:1},
    equip:{weaponId:null,relicId:null},
    hp:60,maxHP:60,
    derived:{},
    status:{}, // battle temps
  };
}

function defaultSlot(){
  const starter=makeNinja("Starter Ninja");
  starter.tp=10;
  return {
    currency:{gold:200, karma:50},
    daily:{lastClaim:0},
    ninjas:[starter],
    activeId:starter.id,
    inventory:{weapons:[], relics:[]},
    shop:{weapons:[], relics:[]},
    meta:{wins:0, losses:0}
  };
}

/* ---------- Profiles (save slots + view other accounts) ---------- */
function loadProfiles(){
  try{
    const raw=localStorage.getItem(PROFILE_KEY);
    if(!raw) return {active:"slot1", slots:{slot1:defaultSlot(), slot2:null, slot3:null}};
    const p=JSON.parse(raw);
    p.active ??= "slot1";
    p.slots ??= {slot1:null,slot2:null,slot3:null};
    if(!p.slots.slot1) p.slots.slot1=defaultSlot();
    return p;
  }catch{
    return {active:"slot1", slots:{slot1:defaultSlot(), slot2:null, slot3:null}};
  }
}
let profiles = loadProfiles();
let save = profiles.slots[profiles.active];

function persistProfiles(){ localStorage.setItem(PROFILE_KEY, JSON.stringify(profiles)); }
function persist(){
  profiles.slots[profiles.active]=save;
  persistProfiles();
}

/* ---------- Accessors ---------- */
function activeNinja(){
  return save.ninjas.find(n=>n.id===save.activeId) || save.ninjas[0];
}
function invWeapon(id){ return save.inventory.weapons.find(w=>w.id===id)||null; }
function invRelic(id){ return save.inventory.relics.find(r=>r.id===id)||null; }

function equipBonus(n){
  const w=n.equip.weaponId?invWeapon(n.equip.weaponId):null;
  const r=n.equip.relicId?invRelic(n.equip.relicId):null;
  return {
    str:(w?.bonus.str||0)+(r?.bonus.str||0),
    agi:(w?.bonus.agi||0)+(r?.bonus.agi||0),
    end:(w?.bonus.end||0)+(r?.bonus.end||0),
    weapon:w,
    relic:r
  };
}
// Ensures a weapon can only be equipped by ONE ninja at a time
function unequipWeaponFromOthers(weaponId, keepNinjaId){
  if(!weaponId) return;
  for(const n of save.ninjas){
    if(n.id !== keepNinjaId && n.equip?.weaponId === weaponId){
      n.equip.weaponId = null;
      recalc(n);
      n.hp = clamp(n.hp, 0, n.maxHP);
    }
  }
}
function recalc(n){
  const eq=equipBonus(n);
  const STR=n.base.str+eq.str;
  const AGI=n.base.agi+eq.agi;
  const END=n.base.end+eq.end;

 const spent = tpSpent(n);
 const spentForLevel = Math.min(spent, MAX_SPENT_FOR_LEVEL);
  n.level = 1 + spentForLevel;

  n.maxHP = 60 + END*12 + n.level*4;
  n.hp = clamp(n.hp ?? n.maxHP, 1, n.maxHP);

  n.derived = {
    STR,AGI,END,
    atk: Math.floor(6 + STR*3 + n.level*1.2),
    def: Math.floor(END + n.level*0.6),
    dodge: clamp(0.03 + AGI*0.015, 0.03, 0.30),
    crit:  clamp(0.04 + AGI*0.008, 0.04, 0.22),
  };
}

/* ---------- Modal helpers ---------- */
function openModal(id){ $(id).classList.remove("hidden"); }
function closeModal(id){ $(id).classList.add("hidden"); }

/* ---------- Top UI ---------- */
function refreshTop(){
  for(const n of save.ninjas) recalc(n);
  const a=activeNinja();
  const spent=tpSpent(a);
  const belt=beltFromSpent(spent);

  $("uiName").textContent=a.name;
  $("uiLevel").textContent=a.level;
  $("uiHP").textContent=`${a.hp}/${a.maxHP}`;
  $("uiTP").textContent=a.tp;
  $("uiBelt").textContent=belt;
  $("uiGold").textContent=save.currency.gold;
  $("uiKarma").textContent=save.currency.karma;
}

/* ---------- Shops stock ---------- */
let weaponSelectedId=null, relicSelectedId=null;

function ensureWeaponStock(){
  if(!save.shop.weapons?.length){
    const dragon = {
      id: "w_dragon_dagger_fixed",
      type: "weapon",
      rarity: "Mythic",
      name: "Dragon Dagger",
      art: "dragonDagger",
      bonus: { str: 25, agi: 25, end: 5 },
      cost: 20000
    };

    // keep dragon always in the shop + fill the rest with random weapons
    save.shop.weapons = [dragon, ...Array.from({length:5}, ()=>makeWeapon())];
  } else {
    // If shop already exists, ensure dragon is present (in case of old saves)
    const hasDragon = save.shop.weapons.some(w => w.id === "w_dragon_dagger_fixed");
    if(!hasDragon){
      const dragon = {
        id: "w_dragon_dagger_fixed",
        type: "weapon",
        rarity: "Mythic",
        name: "Dragon Dagger",
        art: "dragonDagger",
        bonus: { str: 25, agi: 25, end: 5 },
        cost: 20000
      };
      save.shop.weapons.unshift(dragon);
    }
  }
}
    
function ensureRelicStock(){
  if(!save.shop.relics?.length){
    save.shop.relics = Array.from({length:6}, ()=>makeRelic());
  }
}

/* (battle engine + rendering continues in Part 3) */
/* ======================================================
   PART 3 â€” SHOP UI + DOJO UI + DAILY + BATTLE ENGINE (multi-ninja)
   Includes: weapon/relic shop internals, dojo training, equip, and the
   real battle loop (all your owned ninjas fight at once) + variable enemy clan sizes.
====================================================== */

/* ---------- Dojo tabs ---------- */
function setDojoTab(which){
  $("tabTrain").classList.toggle("active", which==="train");
  $("tabNinja").classList.toggle("active", which==="ninja");
  $("paneTrain").classList.toggle("hidden", which!=="train");
  $("paneNinja").classList.toggle("hidden", which!=="ninja");
    if(which==="train"){
    stopDojoPreviewAnim();
    renderDojoTraining();
  }
  if(which==="ninja"){
    renderDojoNinja();
    startDojoPreviewAnim();
  }
}
$("tabTrain").onclick=()=>setDojoTab("train");
$("tabNinja").onclick=()=>setDojoTab("ninja");
$("closeDojo").onclick=()=>{
  stopDojoPreviewAnim();
  closeModal("dojoModal");
};

/* ---------- Training ---------- */
function renderDojoTraining(){
  const a=activeNinja(); recalc(a);
  $("activeHere").textContent=a.name;
  $("tpHere").textContent=a.tp;

  $("stSTR").textContent=a.base.str;
  $("stAGI").textContent=a.base.agi;
  $("stEND").textContent=a.base.end;

  const cS=trainCost(a.base.str);
  const cA=trainCost(a.base.agi);
  const cE=trainCost(a.base.end);
  $("cSTR").textContent=cS;
  $("cAGI").textContent=cA;
  $("cEND").textContent=cE;

  const capped = isLevelCapped(a);

  $("trainSTR").disabled = capped || a.tp < cS;
  $("trainAGI").disabled = capped || a.tp < cA;
  $("trainEND").disabled = capped || a.tp < cE;
}

function spendTP(stat){
  const a=activeNinja();

  if(isLevelCapped(a)){
    alert(`Level cap reached (Lv ${LEVEL_CAP}). Training is locked.`);
    renderDojoTraining();
    return;
  }

  const cost=trainCost(a.base[stat]);
  if(a.tp<cost) return;

  a.tp-=cost;
  a.base[stat]+=1;

  if(tpSpent(a) > MAX_SPENT_FOR_LEVEL){
    a.base[stat]-=1;
    a.tp+=cost;
    alert(`That upgrade would exceed the Lv ${LEVEL_CAP} cap.`);
  }

  recalc(a);
  persist(); refreshTop();
  renderDojoTraining();
  renderDojoNinja();
}

$("trainSTR").onclick=()=>spendTP("str");
$("trainAGI").onclick=()=>spendTP("agi");
$("trainEND").onclick=()=>spendTP("end");
  
/* ---------- Dojo preview drawing (arms + weapon silhouette) ---------- */
function roundRect(ctx,x,y,w,h,r,fill=true){
  const rr=Math.min(r,w/2,h/2);
  ctx.showPath??=(()=>{});
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y, x+w,y+h, rr);
  ctx.arcTo(x+w,y+h, x,y+h, rr);
  ctx.arcTo(x,y+h, x,y, rr);
  ctx.arcTo(x,y, x+w,y, rr);
  ctx.closePath();
  if(fill) ctx.fill();
}

function drawWeaponSilhouette(ctx, kind){
  ctx.save();
  ctx.strokeStyle="rgba(255,255,255,.75)";
  ctx.lineWidth=3;
  ctx.lineCap="round";
  ctx.lineJoin="round";

  if(kind==="katana" || kind==="storm" || kind==="moon"){
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(18,-20); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(6,-6); ctx.lineTo(10,-10); ctx.stroke();
  }else if(kind==="tanto"){
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(10,-10); ctx.stroke();
  }else if(kind==="naginata"){
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(10,-12); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(10,-12); ctx.lineTo(18,-24); ctx.stroke();
  }else if(kind==="staff"){
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(20,-24); ctx.stroke();
  }else if(kind==="fan"){
    ctx.beginPath(); ctx.arc(0,0,10,Math.PI*1.2,Math.PI*1.8); ctx.stroke();
  }else if(kind==="dragonDagger"){
  ctx.save();

  // white glow
  ctx.shadowColor = "rgba(255,255,255,.9)";
  ctx.shadowBlur  = 10;

  // red blade
  ctx.strokeStyle = "rgba(190,20,20,.95)";
  ctx.lineWidth = 2;

  // blade held DOWNWARD
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(0, 22);
  ctx.stroke();

  // tip flare
  ctx.beginPath();
  ctx.moveTo(-3, 20);
  ctx.lineTo(0, 26);
  ctx.lineTo(3, 20);
  ctx.stroke();

  // guard
  ctx.shadowBlur = 0;
  ctx.strokeStyle = "rgba(255,255,255,.85)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-5, 2);
  ctx.lineTo(5, 2);
  ctx.stroke();

  ctx.restore();
  }else if(kind==="chain"){
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(14,-12); ctx.stroke();
    for(let i=0;i<4;i++){
      ctx.beginPath();
      ctx.arc(14+i*4,-12-i*3,2,0,Math.PI*2);
      ctx.stroke();
    }
  }else{
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(16,-18); ctx.stroke();
  }

  ctx.restore();
}

// ---------- Dojo Preview Animation (idle breathing + bob) ----------
let dojoRAF = 0;
let dojoLastT = 0;
let dojoAnimOn = false;

function startDojoPreviewAnim(){
  if(dojoAnimOn) return;
  dojoAnimOn = true;
  dojoLastT = 0;
  dojoRAF = requestAnimationFrame(dojoPreviewLoop);
}

function stopDojoPreviewAnim(){
  dojoAnimOn = false;
  if(dojoRAF) cancelAnimationFrame(dojoRAF);
  dojoRAF = 0;
}

function dojoPreviewLoop(ts){
  if(!dojoAnimOn) return;
  dojoRAF = requestAnimationFrame(dojoPreviewLoop);

  // Only animate when Dojo is visible and Ninja tab is showing
  const modal = document.getElementById("dojoModal");
  const paneN = document.getElementById("paneNinja");
  if(!modal || modal.classList.contains("hidden") || !paneN || paneN.classList.contains("hidden")) return;

  // redraw
  drawDojoPreview(ts);
}

// ---------- Dojo preview helpers (unique names to avoid collisions) ----------
function dojo_rr(ctx,x,y,w,h,r){
  const rr=Math.min(r,w/2,h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y, x+w,y+h, rr);
  ctx.arcTo(x+w,y+h, x,y+h, rr);
  ctx.arcTo(x,y+h, x,y, rr);
  ctx.arcTo(x,y, x+w,y, rr);
  ctx.closePath();
}
function dojo_hash01(str){
  let h = 2166136261;
  for(let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return ((h >>> 0) % 10000) / 10000;
}
function dojo_shadeRGBA(hex, a=1){
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return `rgba(${r},${g},${b},${a})`;
}

// ---------- Dojo preview (MATCH battle colors + wear + glow + breathing) ----------
function drawDojoPreview(ts){
  const c=$("dojoCanvas");
  if(!c) return;
  const ctx=c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);

  const a=activeNinja(); recalc(a);
  const spent=tpSpent(a);
  const belt=beltFromSpent(spent);
  const beltHex = BELT_COLOR[belt] || "#f5f5f5";
  const eq=equipBonus(a);

  // Time-based idle animation
  const t = (ts ? ts/1000 : performance.now()/1000);
  const breathe = 1 + Math.sin(t*2.1)*0.03;
  const bob = Math.sin(t*2.8)*1.6;

  // Match your battle logic:
  // - Black Belt suit is RED
  // - everyone else dark
  const suit = (belt === "Black")
    ? "rgba(170,25,25,.95)"   // RED for Black Belt
    : "rgba(20,20,22,.95)";   // normal dark

  const ink  = "rgba(0,0,0,.9)";
  const trim = "rgba(255,255,255,.82)";

  // Subtle glow for Black Belt
  const glowOn = (belt === "Black");
  const glowCol = "rgba(255,60,60,.55)";

  // background plate
  ctx.save();
  ctx.globalAlpha = 0.20;
  ctx.fillStyle = "rgba(0,0,0,.35)";
  dojo_rr(ctx, 10, 10, 120, 120, 16);
  ctx.fill();
  ctx.restore();

  ctx.save();
  ctx.translate(60,78 + bob);
  ctx.scale(breathe, breathe);

  // If glowing, apply shadow while drawing suit shapes
  if(glowOn){
    ctx.shadowColor = glowCol;
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
  }

  // hood/head
  ctx.fillStyle=suit;
  ctx.beginPath(); ctx.arc(0,-38,16,0,Math.PI*2); ctx.fill();

  // face strip
  ctx.shadowBlur = 0; // keep face clean
  ctx.fillStyle="rgba(245,230,205,.95)";
  roundRect(ctx,-12,-44,24,10,5,true);
  ctx.fillStyle=ink; ctx.fillRect(-10,-40,20,3);

  // mask band (ninja vibe)
  ctx.fillStyle=suit;
  roundRect(ctx,-13,-40,26,8,5,true);

  // body (turn glow back on for suit)
  if(glowOn){
    ctx.shadowColor = glowCol;
    ctx.shadowBlur = 10;
  }
  ctx.fillStyle=suit;
  roundRect(ctx,-18,-26,36,36,12,true);

  // arms
  ctx.shadowBlur = 0;
  ctx.strokeStyle=suit;
  ctx.lineWidth=6;
  ctx.lineCap="round";
  ctx.beginPath(); ctx.moveTo(-16,-18); ctx.lineTo(-30,-4); ctx.stroke();
  ctx.beginPath(); ctx.moveTo( 16,-18); ctx.lineTo( 32,-6); ctx.stroke();

  // belt (with wear texture)
  const bx=-18, by=-6, bw=36, bh=8;
  ctx.fillStyle=dojo_shadeRGBA(beltHex, 0.95);
  roundRect(ctx,bx,by,bw,bh,4,true);

  // belt fold
  ctx.fillStyle="rgba(0,0,0,.18)";
  roundRect(ctx,bx,by+2,bw,2,2,true);

  // knot
  ctx.fillStyle="rgba(0,0,0,.22)";
  roundRect(ctx,-2,by-1,4,bh+2,2,true);

  // tail
  ctx.fillStyle=dojo_shadeRGBA(beltHex, 0.92);
  roundRect(ctx,2,by+bh-1,10,3,2,true);

  // deterministic wear marks (same ninja = same scratches)
  const seed = dojo_hash01(a.id || a.name || "x");
  ctx.save();
  ctx.globalAlpha = 0.22 + seed*0.18;
  ctx.strokeStyle = "rgba(255,255,255,.60)";
  ctx.lineWidth = 1;
  for(let i=0;i<6;i++){
    const tt = (seed*13 + i*0.21) % 1;
    const x = bx + 2 + tt*(bw-4);
    const y = by + 1 + ((seed*7 + i*0.33) % 1)*(bh-2);
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + 3, y + 0.4);
    ctx.stroke();
  }
  ctx.globalAlpha = 0.16;
  ctx.fillStyle = "rgba(0,0,0,.45)";
  for(let i=0;i<5;i++){
    const tt = (seed*19 + i*0.27) % 1;
    ctx.fillRect(bx + 2 + tt*(bw-4), by + 1, 1, 1);
  }
  ctx.restore();

  // legs
  ctx.fillStyle=suit;
  roundRect(ctx,-16,10,14,12,6,true);
  roundRect(ctx,  2,10,14,12,6,true);

  // headband trim
  ctx.fillStyle=trim;
  roundRect(ctx,-18,-52,36,7,4,true);

  // weapon in right hand
  ctx.save();
  ctx.translate(34,-8);
  if(eq.weapon){
    drawWeaponSilhouette(ctx, eq.weapon.art);
  }else{
    ctx.strokeStyle="rgba(255,255,255,.25)";
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(14,-14); ctx.stroke();
  }
  ctx.restore();

  ctx.restore();
}

function renderDojoNinja(){
  const a=activeNinja(); recalc(a);
  const eq=equipBonus(a);
  const spent=tpSpent(a);
  const belt=beltFromSpent(spent);

  $("djName").textContent = `${a.name} (Lv ${a.level})`;
  $("djLine").textContent = `HP ${a.hp}/${a.maxHP} â€¢ TP ${a.tp} â€¢ Spent ${spent}`;
  $("djBelt").textContent = `Belt: ${belt}`;

  $("djBase").textContent = `${a.base.str}/${a.base.agi}/${a.base.end}`;
  $("djBonus").textContent = `+${eq.str}/+${eq.agi}/+${eq.end}`;
  $("djDerived").textContent = `${a.derived.atk}/${a.derived.def}/${Math.round(a.derived.dodge*100)}%`;

  const wName = eq.weapon ? `${eq.weapon.name} (${eq.weapon.rarity})` : "None";
  const rName = eq.relic ? `${eq.relic.name} (${eq.relic.rarity})` : "None";
  $("djEquipped").textContent = `Weapon: ${wName} â€¢ Relic: ${rName}`;

  // Owned weapon select
  const wSel=$("djWeaponSelect");
  wSel.innerHTML = `<option value="">None</option>`;
  for(const w of save.inventory.weapons){
    const opt=document.createElement("option");
    opt.value=w.id;
    opt.textContent=`${w.name} [${w.rarity}] (+${w.bonus.str}/+${w.bonus.agi}/+${w.bonus.end})`;
    if(a.equip.weaponId===w.id) opt.selected=true;
    wSel.appendChild(opt);
  }

  // Owned relic select
  const rSel=$("djRelicSelect");
  rSel.innerHTML = `<option value="">None</option>`;
  for(const r of save.inventory.relics){
    const opt=document.createElement("option");
    opt.value=r.id;
    opt.textContent=`${r.name} [${r.rarity}] (+${r.bonus.str}/+${r.bonus.agi}/+${r.bonus.end})`;
    if(a.equip.relicId===r.id) opt.selected=true;
    rSel.appendChild(opt);
  }

  drawDojoPreview();
}

$("djEquipWeapon").onclick=()=>{
  const a = activeNinja();
  const wid = $("djWeaponSelect").value || null;

  unequipWeaponFromOthers(wid, a.id);
  a.equip.weaponId = wid;

  recalc(a); persist(); refreshTop(); renderDojoNinja();
};
$("djUnequipWeapon").onclick=()=>{
  const a=activeNinja();
  a.equip.weaponId=null;
  recalc(a); persist(); refreshTop(); renderDojoNinja();
};
$("djEquipRelic").onclick=()=>{
  const a=activeNinja();
  a.equip.relicId = $("djRelicSelect").value || null;
  recalc(a); persist(); refreshTop(); renderDojoNinja();
};
$("djUnequipRelic").onclick=()=>{
  const a=activeNinja();
  a.equip.relicId=null;
  recalc(a); persist(); refreshTop(); renderDojoNinja();
};

/* ---------- Daimyo ---------- */
$("closeDai").onclick=()=>closeModal("daiModal");
function renderDaimyo(){
  const a=activeNinja();
  const spent=tpSpent(a);
  $("dBelt").textContent=beltFromSpent(spent);
  $("dLevel").textContent=a.level;
  $("dSpent").textContent=spent;
}

/* ---------- Recruit ---------- */
$("closeRecruit").onclick=()=>closeModal("recruitModal");
let rosterSelectedId=null;

function recruitCost(){
  return 200 + (save.ninjas.length-1)*150;
}
function renderRoster(){
  const cost=recruitCost();
  $("recruitCost").textContent=cost;
  $("recruitBtn").disabled = save.currency.gold < cost;

  const list=$("rosterList");
  list.innerHTML="";
  for(const n of save.ninjas){
    recalc(n);
    const isActive = n.id===save.activeId;
    const selected = n.id===rosterSelectedId;

    const row=document.createElement("div");
    row.className="item";
    row.style.background = selected ? "rgba(255,255,255,.35)" : "";
    row.innerHTML=`
      <div style="min-width:0">
        <div style="font-weight:1000;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">
          ${n.name} <span class="pill">Lv${n.level}</span> ${isActive?`<span class="pill">ACTIVE</span>`:""}
        </div>
        <div class="muted">STR ${n.derived.STR} â€¢ AGI ${n.derived.AGI} â€¢ END ${n.derived.END} â€¢ HP ${n.hp}/${n.maxHP}</div>
      </div>
      <button class="btn ghost small" data-sel="${n.id}">${selected?"Selected":"Select"}</button>
    `;
    list.appendChild(row);
  }
  list.querySelectorAll("button[data-sel]").forEach(btn=>{
    btn.onclick=()=>{ rosterSelectedId=btn.getAttribute("data-sel"); renderRoster(); };
  });

  $("setActiveBtn").disabled = !rosterSelectedId;
}

$("recruitBtn").onclick=()=>{
  const cost=recruitCost();
  if(save.currency.gold < cost) return;

  save.currency.gold -= cost;
  const n=makeNinja();
  n.tp = 0;
  recalc(n);
  save.ninjas.push(n);
  rosterSelectedId=n.id;

  persist(); refreshTop(); renderRoster();
};
$("setActiveBtn").onclick=()=>{
  if(!rosterSelectedId) return;
  save.activeId=rosterSelectedId;
  persist(); refreshTop(); renderRoster();
};

/* ---------- Weapon Shop UI ---------- */
function renderWeaponShop(){
  ensureWeaponStock();
  const list=$("weaponList"); list.innerHTML="";

  for(const w of save.shop.weapons){
    const selected = w.id===weaponSelectedId;
    const owned = save.inventory.weapons.some(x=>x.id===w.id);

    const row=document.createElement("div");
    row.className="item";
    row.style.background = selected ? "rgba(255,255,255,.35)" : "";
    row.innerHTML=`
      <div style="min-width:0">
        <div style="font-weight:1000">
          ${w.name} <span class="pill rar ${w.rarity}">${w.rarity}</span>
          <span class="pill">ðŸª™ ${Math.round(w.cost)}</span> ${owned?`<span class="pill">OWNED</span>`:""}
        </div>
        <div class="muted">+STR ${w.bonus.str} â€¢ +AGI ${w.bonus.agi} â€¢ +END ${w.bonus.end}</div>
      </div>
      <button class="btn ghost small" data-wsel="${w.id}">${selected?"Selected":"Select"}</button>
    `;
    list.appendChild(row);
  }

  list.querySelectorAll("button[data-wsel]").forEach(b=>{
    b.onclick=()=>{ weaponSelectedId=b.getAttribute("data-wsel"); renderWeaponShop(); };
  });

  const sel = save.shop.weapons.find(x=>x.id===weaponSelectedId) || null;
  $("buyWeaponBtn").disabled = !sel || save.currency.gold < sel.cost || save.inventory.weapons.some(x=>x.id===sel.id);
  $("equipWeaponBtn").disabled = !sel || (!save.inventory.weapons.some(x=>x.id===sel.id) && save.currency.gold < sel.cost);
}

$("buyWeaponBtn").onclick=()=>{
  const sel = save.shop.weapons.find(x=>x.id===weaponSelectedId) || null;
  if(!sel) return;
  if(save.currency.gold < sel.cost) return;
  if(save.inventory.weapons.some(x=>x.id===sel.id)) return;
  save.currency.gold -= Math.round(sel.cost);
  save.inventory.weapons.push(sel);
  persist(); refreshTop();
  renderWeaponShop();
  renderDojoNinja();
};

$("equipWeaponBtn").onclick=()=>{
  const sel = save.shop.weapons.find(x=>x.id===weaponSelectedId) || null;
  if(!sel) return;

  if(!save.inventory.weapons.some(x=>x.id===sel.id)){
    if(save.currency.gold < sel.cost) return;
    save.currency.gold -= Math.round(sel.cost);
    save.inventory.weapons.push(sel);
  }

  const a = activeNinja();
  unequipWeaponFromOthers(sel.id, a.id);
  a.equip.weaponId = sel.id;

  recalc(a);
  persist();
  refreshTop();
  renderWeaponShop();
  renderDojoNinja();
};

$("refreshWeaponBtn").onclick=()=>{
  save.shop.weapons = Array.from({length:6}, ()=>makeWeapon());
  weaponSelectedId = save.shop.weapons[0]?.id || null;
  persist();
  renderWeaponShop();
};

$("closeWeapon").onclick=()=>closeModal("weaponModal");

/* ---------- Relic Shop UI ---------- */
function renderRelicShop(){
  ensureRelicStock();
  const list=$("relicList"); list.innerHTML="";

  for(const r of save.shop.relics){
    const selected = r.id===relicSelectedId;
    const owned = save.inventory.relics.some(x=>x.id===r.id);

    const row=document.createElement("div");
    row.className="item";
    row.style.background = selected ? "rgba(255,255,255,.35)" : "";
    row.innerHTML=`
      <div style="min-width:0">
        <div style="font-weight:1000">
          ${r.name} <span class="pill rar ${r.rarity}">${r.rarity}</span>
          <span class="pill">â˜¯ ${Math.round(r.cost)}</span> ${owned?`<span class="pill">OWNED</span>`:""}
        </div>
        <div class="muted">+STR ${r.bonus.str} â€¢ +AGI ${r.bonus.agi} â€¢ +END ${r.bonus.end}</div>
      </div>
      <button class="btn ghost small" data-rsel="${r.id}">${selected?"Selected":"Select"}</button>
    `;
    list.appendChild(row);
  }

  list.querySelectorAll("button[data-rsel]").forEach(b=>{
    b.onclick=()=>{ relicSelectedId=b.getAttribute("data-rsel"); renderRelicShop(); };
  });

  const sel = save.shop.relics.find(x=>x.id===relicSelectedId) || null;
  $("buyRelicBtn").disabled = !sel || save.currency.karma < sel.cost || save.inventory.relics.some(x=>x.id===sel.id);
  $("equipRelicBtn").disabled = !sel || (!save.inventory.relics.some(x=>x.id===sel.id) && save.currency.karma < sel.cost);
}

$("buyRelicBtn").onclick=()=>{
  const sel = save.shop.relics.find(x=>x.id===relicSelectedId) || null;
  if(!sel) return;
  if(save.currency.karma < sel.cost) return;
  if(save.inventory.relics.some(x=>x.id===sel.id)) return;
  save.currency.karma -= Math.round(sel.cost);
  save.inventory.relics.push(sel);
  persist(); refreshTop();
  renderRelicShop();
  renderDojoNinja();
};

$("equipRelicBtn").onclick=()=>{
  const sel = save.shop.relics.find(x=>x.id===relicSelectedId) || null;
  if(!sel) return;

  if(!save.inventory.relics.some(x=>x.id===sel.id)){
    if(save.currency.karma < sel.cost) return;
    save.currency.karma -= Math.round(sel.cost);
    save.inventory.relics.push(sel);
  }
  const a=activeNinja();
  a.equip.relicId=sel.id;
  recalc(a);
  persist(); refreshTop();
  renderRelicShop();
  renderDojoNinja();
};

$("refreshRelicBtn").onclick=()=>{
  save.shop.relics = Array.from({length:6}, ()=>makeRelic());
  relicSelectedId = save.shop.relics[0]?.id || null;
  persist();
  renderRelicShop();
};
$("closeRelic").onclick=()=>closeModal("relicModal");

/* ---------- Profiles modal ---------- */
$("closeProfiles").onclick=()=>closeModal("profilesModal");

function slotSummary(slot){
  if(!slot) return "Empty slot";
  const a = slot.ninjas?.[0];
  if(!a) return "Empty slot";
  const spent = (a.base?.str-1||0)+(a.base?.agi-1||0)+(a.base?.end-1||0);
  const belt = beltFromSpent(spent);
  return `${slot.ninjas.length} ninjas â€¢ ${belt} â€¢ ðŸª™${slot.currency.gold} â€¢ â˜¯${slot.currency.karma}`;
}

function renderProfiles(){
  const list=$("profilesList");
  list.innerHTML="";

  for(const sname of ["slot1","slot2","slot3"]){
    const slot = profiles.slots[sname];
    const isActive = profiles.active===sname;

    const row=document.createElement("div");
    row.className="item";
    row.innerHTML=`
      <div>
        <div style="font-weight:1000">${sname.toUpperCase()} ${isActive?`<span class="pill">ACTIVE</span>`:""}</div>
        <div class="muted">${slotSummary(slot)}</div>
      </div>
      <div class="row">
        <button class="btn ghost small" data-load="${sname}">Load</button>
        <button class="btn ghost small" data-new="${sname}">${slot?"Reset":"Create"}</button>
      </div>
    `;
    list.appendChild(row);
  }

  list.querySelectorAll("button[data-load]").forEach(b=>{
    b.onclick=()=>{
      const sn=b.getAttribute("data-load");
      if(!profiles.slots[sn]) return;
      profiles.active=sn;
      save=profiles.slots[sn];
      persistProfiles();
      refreshTop();
      closeModal("profilesModal");
    };
  });

  list.querySelectorAll("button[data-new]").forEach(b=>{
    b.onclick=()=>{
      const sn=b.getAttribute("data-new");
      profiles.slots[sn]=defaultSlot();
      profiles.active=sn;
      save=profiles.slots[sn];
      persistProfiles();
      refreshTop();
      closeModal("profilesModal");
    };
  });
}

/* ---------- Daily meditation (30 min TP reward) ---------- */
$("dailyBtn").onclick=()=>{
  const now=Date.now();
  const last=save.daily?.lastClaim||0;
  const cd=30*60*1000;
  if(now-last < cd){
    const mins=Math.ceil((cd-(now-last))/60000);
    alert(`Come back in ${mins} min`);
    return;
  }
  const a=activeNinja();
  a.tp += 3;
  save.daily.lastClaim = now;
  persist(); refreshTop();
  alert("+3 TP!");
};

/* ======================================================
   BATTLE ENGINE â€” SINGLE DROP-IN REPLACEMENT (COPY/PASTE)
   Fixes:
   - Battle works repeatedly (sequence resets every battle + RAF always running)
   - Auto can pause/resume properly
   - Ninjas look more like ninjas (mask + eyes + headband)
   - Fighters run MUCH closer to target when striking
   Requires DOM ids (already in your file):
     #battleCanvas, #bhLeft #bhMid #bhRight
     #battleTitle #battleSub #battleText
     #battleAutoBtn #battleRetreatBtn
     #battleSelectModal #battleList #closeBattleSelect
     #town #battle
====================================================== */

let battleState = null;
let battleRAF = 0;
let battleLastT = 0;

// â€œAutoâ€ is true by default per your design
let battleAutoOn = true;

let battleCanvas = null;
let bctx = null;

const lerp = (a,b,t)=>a+(b-a)*t;
const easeOut = (t)=>1-Math.pow(1-t,3);
const easeInOut = (t)=>t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;

// ---------- init renderer (safe) ----------
function initBattleRenderer(){
  battleCanvas = document.getElementById("battleCanvas");
  if(!battleCanvas) return;
  bctx = battleCanvas.getContext("2d");
}

// ---------- helpers ----------
function living(team){ return team.filter(n=>n.hp>0); }
function pickTarget(team){
  const alive=living(team);
  return alive.length ? pick(alive) : null;
}
function getById(id){
  return [...battleState.your, ...battleState.enemy].find(n=>n.id===id) || null;
}

function rebuildWaitingLists(){
  const inDuel = new Set();
  for(const d of battleState.duels){
    if(d.aId) inDuel.add(d.aId);
    if(d.bId) inDuel.add(d.bId);
  }

  battleState.waitingYour  = living(battleState.your).map(n=>n.id).filter(id=>!inDuel.has(id));
  battleState.waitingEnemy = living(battleState.enemy).map(n=>n.id).filter(id=>!inDuel.has(id));

  // fastest first (optional but nice)
  battleState.waitingYour.sort((A,B)=>speedScore(getById(B))-speedScore(getById(A)));
  battleState.waitingEnemy.sort((A,B)=>speedScore(getById(B))-speedScore(getById(A)));
}
function rollHit(att, def){
  const dodge = def.derived.dodge;
  if(Math.random() < dodge) return {hit:false, crit:false};
  const crit = Math.random() < (att.derived.crit||0.08);
  return {hit:true, crit};
}

function dealDamage(att, def, mult=1){
  const base = att.derived.atk;
  const mitigation = 1 - clamp(def.derived.def/(def.derived.def+50), 0.15, 0.65);
  let dmg = Math.max(1, Math.floor(base * mitigation * mult));

  const r = rollHit(att, def);
  if(!r.hit) return {dmg:0, dodged:true, crit:false};
  if(r.crit) dmg = Math.floor(dmg*1.55);

  def.hp = clamp(def.hp - dmg, 0, def.maxHP);
  return {dmg, dodged:false, crit:r.crit};
}
function comboChance(att){
  // Example scaling: ~6% at AGI 1, ~22% at AGI 40, caps at 40%
  const agi = att?.derived?.AGI || 0;
  return clamp(0.06 + agi * 0.004, 0.06, 0.40);
}

function tryComboHit(att, def){
  if(!att || !def) return null;
  if(def.hp <= 0) return null;

  if(Math.random() >= comboChance(att)) return null;

  // Optional: slightly weaker combo hit so itâ€™s not broken
  return dealDamage(att, def, 0.75);
}
function speedScore(n){ return n.derived.AGI + n.level*0.25 + rand(-0.5,0.5); }
function buildTurnOrder(){
  const all=[...battleState.your, ...battleState.enemy].filter(n=>n.hp>0);
  all.sort((a,b)=>speedScore(b)-speedScore(a));
  return all;
}

function battleLogPush(line){
  if(!battleState) return;
  battleState.log.push(line);
  if(battleState.log.length>160) battleState.log.shift();
  renderBattleHUD();
}
function scrollBattleLogToBottom(){
  const box = document.getElementById("battleLog");
  if(!box) return;

  const nearBottom = (box.scrollTop + box.clientHeight) >= (box.scrollHeight - 12);
  if(nearBottom) box.scrollTop = box.scrollHeight;
}

// ---------- enemy creation ----------
function makeEnemyNinja(template){
  const n = makeNinja(template?.name || null);
  n.tp = 0;
  n.base.str = template.str;
  n.base.agi = template.agi;
  n.base.end = template.end;
  n.equip.weaponId = null;
  n.equip.relicId  = null;
  n.hp = null;
  recalc(n);
  n.hp = n.maxHP;
  n.isEnemy = true;
  n.isBoss  = !!template?.isBoss;
  return n;
}

function makeScoutEnemy(){
  return [ makeEnemyNinja({ name:"Scout", str:1, agi:1, end:1, isBoss:false }) ];
}

function clampEnemyStat(v){ return clamp(Math.floor(v), 1, 60); }

function genEnemyClan(difficulty){
  if(difficulty === "easy") return makeScoutEnemy();

  const yourCount = save.ninjas.length;
  const base =
    difficulty==="medium" ? rint(3,5) :
    difficulty==="hard"   ? rint(4,7) :
    rint(2,4);

  const size = clamp(base + rint(-1,1) + Math.floor(yourCount*0.25), 1, 10);

  const avgLv = Math.max(
    1,
    Math.round(save.ninjas.reduce((s,n)=>{ recalc(n); return s+n.level; },0) / save.ninjas.length)
  );

const statBase =
  difficulty==="medium" ? avgLv*0.75 :
  difficulty==="hard"   ? avgLv*1.1 :
  avgLv*0.75;

const pool = statBase * 3;

const clan=[];
for(let i=0;i<size;i++){
  const spread=[1+rand(-0.15,0.25),1+rand(-0.15,0.25),1+rand(-0.15,0.25)];
  const sum=spread[0]+spread[1]+spread[2];
  const s = clampEnemyStat(pool * (spread[0]/sum));
  const a = clampEnemyStat(pool * (spread[1]/sum));
  const e = clampEnemyStat(pool * (spread[2]/sum));
  clan.push(makeEnemyNinja({str:s, agi:a, end:e}));
}
return clan;
}

function makeBossEnemy(){
  const spent=80;
  const each=Math.floor(spent/3);
  const rem=spent - each*3;
  const baseStr=1+each + (rem>0?1:0);
  const baseAgi=1+each + (rem>1?1:0);
  const baseEnd=1+each;

  const boss = makeEnemyNinja({name:"Boss Ronin", str:baseStr, agi:baseAgi, end:baseEnd, isBoss:true});
  boss.base.str += 100; boss.base.agi += 100; boss.base.end += 1000;
  recalc(boss); boss.hp=boss.maxHP;
  boss.isBoss=true;
  return [boss];
}

// ---------- your team ----------
function battleTeamYour(){
  return save.ninjas.map(n=>{
    recalc(n);
    n.hp = clamp(n.hp ?? n.maxHP, 1, n.maxHP);
    n.isEnemy=false;
    n.isBoss=false;
    return n;
  });
}

/* ============================
   VISUAL MODEL (closer run + mask)
============================ */
function makeFighterVisual(n, side, idx){
  const x = side==="L" ? 210 : 750;
  const y = 210 + idx*75;

  return {
    id: n.id,
    side,
    lane: idx,
    baseX: x, baseY: y,
    x, y,
    bob: rand(0, Math.PI*2),
    run: 0,        // 0..1 how â€œforwardâ€ they are in current strike
    hitFlash: 0,   // 0..1
    koFade: 0,     // 0..1
    hpPulse: 0,    // 0..1
    floating: [],
    swing: 0,        // 0..1 (swing intensity)
    swingDir: 1,     // 1 or -1 (alternates)
  };
}

function syncVisuals(){
  battleState.visuals = battleState.visuals || { L:[], R:[] };

  battleState.visuals.L = battleState.your.map((n,i)=>{
    return battleState.visuals.L.find(v=>v.id===n.id) || makeFighterVisual(n,"L",i);
  });
  battleState.visuals.R = battleState.enemy.map((n,i)=>{
    return battleState.visuals.R.find(v=>v.id===n.id) || makeFighterVisual(n,"R",i);
  });

  battleState.visuals.L.forEach((v,i)=>{ v.lane=i; v.baseY=210+i*75; });
  battleState.visuals.R.forEach((v,i)=>{ v.lane=i; v.baseY=210+i*75; });
}

function visFor(n){
  const arr = n.isEnemy ? battleState.visuals.R : battleState.visuals.L;
  return arr.find(v=>v.id===n.id) || null;
}

/* ============================
   ACTION QUEUE (resets every battle)
============================ */
/* ============================
   DUEL LANES (parallel 1v1s)
   - Up to min(aliveYour, aliveEnemy) fights at once
   - If 1v3, only 1 lane runs
============================ */

const MAX_LANES = 5; // cap if you want (10 is fine)

function ensureDuels(){
  if(!battleState || battleState.over) return;

  syncVisuals();

  // remove broken duels (dead or missing)
  battleState.duels = battleState.duels.filter(d=>{
    const a = getById(d.aId);
    const b = getById(d.bId);
    return a && b && a.hp>0 && b.hp>0;
  });

  rebuildWaitingLists();

  const lanesAllowed = Math.min(
    living(battleState.your).length,
    living(battleState.enemy).length,
    MAX_LANES
  );

  // create duels until we hit allowed lanes
  while(battleState.duels.length < lanesAllowed){
    const aId = battleState.waitingYour.shift();
    const bId = battleState.waitingEnemy.shift();
    if(!aId || !bId) break;

    battleState.duels.push({
      aId, bId,
      t: 0,
      didClash: false,
      duration: 0.30,
      strikeAt: 0.35
    });
  }

  // OPTIONAL: align active fighters into duel rows visually
  const laneMapYour = new Map();
  const laneMapEnemy = new Map();
  battleState.duels.forEach((d, i)=>{
    laneMapYour.set(d.aId, i);
    laneMapEnemy.set(d.bId, i);
  });

  battleState.visuals.L.forEach(v=>{
    if(laneMapYour.has(v.id)){
      const lane = laneMapYour.get(v.id);
      v.lane = lane;
      v.baseY = 210 + lane*75;
    }
  });
  battleState.visuals.R.forEach(v=>{
    if(laneMapEnemy.has(v.id)){
      const lane = laneMapEnemy.get(v.id);
      v.lane = lane;
      v.baseY = 210 + lane*75;
    }
  });
}

function stepDuels(dt){
  if(!battleState || battleState.over) return;

  if(living(battleState.enemy).length===0){ endBattle(true); return; }
  if(living(battleState.your).length===0){ endBattle(false); return; }

  ensureDuels();

  for(const duel of battleState.duels){
    const a = getById(duel.aId);
    const b = getById(duel.bId);
    if(!a || !b || a.hp<=0 || b.hp<=0) continue;

    const va = visFor(a);
    const vb = visFor(b);

    duel.t += dt;
    const p = clamp(duel.t / duel.duration, 0, 1);

    // run both to middle
    if(va){
      const midX = battleCanvas.width/2;
      const endX = (va.side==="L") ? (midX - 55) : (midX + 55);
      const runIn = 0.45;
      const runT = (p < runIn) ? easeOut(p/runIn)
                : (1 - easeOut((p-runIn)/(1-runIn)));
      va.run = clamp(runT, 0, 1);
      va.x = lerp(va.baseX, endX, va.run);
      const s = 1 - Math.min(1, Math.abs(p - duel.strikeAt) / 0.20);
      va.swing = Math.max(va.swing||0, s);
    }
    if(vb){
      const midX = battleCanvas.width/2;
      const endX = (vb.side==="L") ? (midX - 55) : (midX + 55);
      const runIn = 0.45;
      const runT = (p < runIn) ? easeOut(p/runIn)
                : (1 - easeOut((p-runIn)/(1-runIn)));
      vb.run = clamp(runT, 0, 1);
      vb.x = lerp(vb.baseX, endX, vb.run);
      const s = 1 - Math.min(1, Math.abs(p - duel.strikeAt) / 0.20);
      vb.swing = Math.max(vb.swing||0, s);
    }

    // clash moment
    if(!duel.didClash && p >= duel.strikeAt){
      duel.didClash = true;
      if (va) va.swingDir = (va.swingDir || 1) * -1;
      if (vb) vb.swingDir = (vb.swingDir || 1) * -1;

      const resAB = dealDamage(a, b, 1);
      // ---- COMBO (A hits B again) ----
const comboAB = tryComboHit(a, b);
if(comboAB){
  // Flip swing direction so the second hit looks like a follow-up slash
  if(va) va.swingDir = (va.swingDir || 1) * -1;

  if(comboAB.dodged){
    if(vb) vb.floating.push({ text:"COMBO DODGE", x:vb.x, y:vb.y-50, vy:-28, life:0.9, crit:false });
  }else{
    if(vb){
      vb.hitFlash = 1; vb.hpPulse = 1;
      vb.floating.push({ text:`COMBO -${comboAB.dmg}`, x:vb.x, y:vb.y-52, vy:-34, life:0.95, crit:comboAB.crit });
    }
  }
}
      const resBA = (b.hp>0) ? dealDamage(b, a, 1) : {dmg:0, dodged:false, crit:false};
// ---- COMBO (B hits A again) ----
if(b.hp > 0 && a.hp > 0){
  const comboBA = tryComboHit(b, a);
  if(comboBA){
    if(vb) vb.swingDir = (vb.swingDir || 1) * -1;

    if(comboBA.dodged){
      if(va) va.floating.push({ text:"COMBO DODGE", x:va.x, y:va.y-50, vy:-28, life:0.9, crit:false });
    }else{
      if(va){
        va.hitFlash = 1; va.hpPulse = 1;
        va.floating.push({ text:`COMBO -${comboBA.dmg}`, x:va.x, y:va.y-52, vy:-34, life:0.95, crit:comboBA.crit });
      }
    }
  }
}
      
      if(resAB.dodged){
        if(vb) vb.floating.push({ text:"DODGE", x:vb.x, y:vb.y-32, vy:-26, life:0.9, crit:false });
      }else if(vb){
        vb.hitFlash=1; vb.hpPulse=1;
        vb.floating.push({ text:`-${resAB.dmg}`, x:vb.x, y:vb.y-36, vy:-30, life:0.95, crit:resAB.crit });
      }

      if(resBA.dodged){
        if(va) va.floating.push({ text:"DODGE", x:va.x, y:va.y-32, vy:-26, life:0.9, crit:false });
      }else if(va){
        va.hitFlash=1; va.hpPulse=1;
        va.floating.push({ text:`-${resBA.dmg}`, x:va.x, y:va.y-36, vy:-30, life:0.95, crit:resBA.crit });
      }
    }

    // cycle repeats
    if(p >= 1){
      if(va) va.run = 0;
      if(vb) vb.run = 0;
      duel.t = 0;
      duel.didClash = false;
    }
  }
}

/* ============================
   END / REWARDS + HARD RESET
============================ */
function endBattle(victory){
  if(!battleState) return;
  if(battleState.over) return;

  battleState.over = true;
  battleState.victory = victory;

  const rewardGold  = victory ? (120 + battleState.enemyStart * 35) : 40;
  const rewardKarma = victory ? (25  + battleState.enemyStart * 8)  : 10;

  save.currency.gold  += rewardGold;
  save.currency.karma += rewardKarma;

  let tpAward = 0;

  if (victory) {
    const tpPerEnemy = 1;
    tpAward = battleState.enemyStart * tpPerEnemy + 1; // leader bonus


    const active = activeNinja();
    if(!isLevelCapped(active)) active.tp += tpAward;
    
      }

  save.meta.wins   = save.meta.wins   || 0;
  save.meta.losses = save.meta.losses || 0;
  victory ? save.meta.wins++ : save.meta.losses++;

  battleLogPush(
    victory
      ? `ðŸ Victory! Rewards: ðŸª™${rewardGold}, â˜¯${rewardKarma}, +${tpAward} TP`
      : `ðŸ Defeatâ€¦ Consolation: ðŸª™${rewardGold}, â˜¯${rewardKarma}`
  );

  battleAutoOn = false;

  persist();
  refreshTop();
  renderBattleHUD();
}

/* ============================
   START / LEAVE (FIXES â€œone battle then deadâ€)
============================ */
function resetBattleRuntime(){
  // This is the key fix: new battle must reset runtime counters and queue visuals cleanly
  battleLastT = 0;
  battleAutoOn = true; // auto starts ON each new battle
}

function startBattle(kind){
  initBattleRenderer();
  resetBattleRuntime();

  const your  = battleTeamYour();
  const enemy =
    (kind==="boss")   ? makeBossEnemy()
  : (kind==="hard")   ? genEnemyClan("hard")
  : (kind==="medium") ? genEnemyClan("medium")
  : genEnemyClan("easy");

  // HARD RESET STATE
  battleState = {
    kind,
    round: 1,
    over: false,
    victory: false,
    your,
    enemy,
    enemyStart: enemy.length,
    log: [`âš”ï¸ Battle start: ${kind.toUpperCase()} â€” Your clan ${your.length} vs Enemy ${enemy.length}`],
    duels: [],
    waitingYour: [],
    waitingEnemy: [],
    visuals: {L:[], R:[]}
  };

  syncVisuals();
  ensureDuels();

  document.getElementById("town")?.classList.add("hidden");
  document.getElementById("battle")?.classList.remove("hidden");

  renderBattleHUD();

  // Ensure RAF loop is running (forever). This fixes â€œafter first battle nothing happensâ€.
  if(!battleRAF) battleRAF = requestAnimationFrame(battleLoop);
}

function leaveBattle(){
  // Do NOT cancel RAF. Keep it running so next battle animates.
  battleState = null;

  document.getElementById("battle")?.classList.add("hidden");
  document.getElementById("town")?.classList.remove("hidden");
}

/* ============================
   HUD + LOG + AUTO TOGGLE (REAL PAUSE)
============================ */
function renderBattleHUD(){
  if(!battleState) return;

  const yAlive = living(battleState.your).length;
  const eAlive = living(battleState.enemy).length;

  document.getElementById("bhLeft").textContent  = `Your: ${yAlive}/${battleState.your.length}`;
  document.getElementById("bhMid").textContent   = `Round ${battleState.round} â€¢ ${battleState.kind.toUpperCase()}`;
  document.getElementById("bhRight").textContent = `Enemy: ${eAlive}/${battleState.enemy.length}`;

  document.getElementById("battleTitle").textContent = battleState.over
    ? (battleState.victory ? "Victory!" : "Defeatâ€¦")
    : "Battle";

  document.getElementById("battleSub").textContent =
    `Your ${battleState.your.length} vs Enemy ${battleState.enemy.length} (start ${battleState.enemyStart})`;

  const bt = document.getElementById("battleText");
  bt.style.whiteSpace = "pre-line";
  bt.textContent = (battleState.log.slice(-8).join("\n")) || "â€”";
  scrollBattleLogToBottom();

  // Hide/disable Next (engine is auto-driven)
  const nextBtn = document.getElementById("battleNextBtn");
  if(nextBtn){
    nextBtn.disabled = true;
    nextBtn.style.display = "none";
  }

  const autoBtn = document.getElementById("battleAutoBtn");
  if(autoBtn){
    autoBtn.disabled = battleState.over;
    autoBtn.textContent = battleState.over ? "Auto" : (battleAutoOn ? "Auto: ON" : "Auto: OFF");
  }
}

/* ============================
   RENDERER (masked ninjas) + HEALTH STACKS
============================ */
function updateVisuals(dt){
  if(!battleState) return;
  syncVisuals();

  const updateOne = (n, v)=>{
    v.bob += dt * 3.0;
    const bobY = Math.sin(v.bob) * 2.2;

    // if not actively running in an action, gently return x to baseX
    if(v.run <= 0.0001){
      v.x = lerp(v.x, v.baseX, clamp(dt*6.5, 0, 1));
    }
    v.y = v.baseY + bobY;

    if(v.hitFlash>0) v.hitFlash = Math.max(0, v.hitFlash - dt*3.6);
    if(v.hpPulse>0)  v.hpPulse  = Math.max(0, v.hpPulse  - dt*3.0);

    if(n.hp<=0) v.koFade = Math.min(1, (v.koFade||0) + dt*0.6);
    else v.koFade = 0;

    v.floating = v.floating.filter(f=>f.life>0);
    for(const f of v.floating){
      f.life -= dt;
      f.y += f.vy*dt;
      f.vy -= 22*dt;
    }
  };

  battleState.your.forEach(n=>{ const v=visFor(n); if(v) updateOne(n,v); });
  battleState.enemy.forEach(n=>{ const v=visFor(n); if(v) updateOne(n,v); });
}

function drawHealthStacks(){
  const ctx = bctx;
  const w = battleCanvas.width;

  const drawStack = (team, side)=>{
    const alive = living(team);
    const x0 = side==="L" ? 16 : w-16;
    const alignRight = side==="R";

    const barW = 260;
    const barH = 13;
    const gap = 8;

    alive.slice(0,5).forEach((n,i)=>{
      const y = 14 + i*(barH+gap);
      const pct = n.maxHP ? (n.hp/n.maxHP) : 0;
      const name = n.isBoss ? "Boss" : (n.isEnemy ? "Enemy" : n.name);

      const bx = alignRight ? (x0 - barW) : x0;

      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.fillRect(bx, y, barW, barH);

      ctx.fillStyle = "rgba(255,255,255,.86)";
      ctx.fillRect(bx, y, Math.max(0, barW*pct), barH);

      ctx.strokeStyle = "rgba(0,0,0,.55)";
      ctx.lineWidth = 1;
      ctx.strokeRect(bx+0.5, y+0.5, barW-1, barH-1);

      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(0,0,0,.85)";
      ctx.font = "900 10px system-ui";
      const label = `${name}  ${n.hp}/${n.maxHP}`;
      const tx = alignRight ? (bx + barW - 6) : (bx + 6);
      ctx.textAlign = alignRight ? "right" : "left";
      ctx.textBaseline = "middle";
      ctx.fillText(label, tx, y + barH/2);
    });
  };

  drawStack(battleState.your, "L");
  drawStack(battleState.enemy, "R");
}

function rr(ctx,x,y,w,h,r){
  const rr=Math.min(r,w/2,h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y, x+w,y+h, rr);
  ctx.arcTo(x+w,y+h, x,y+h, rr);
  ctx.arcTo(x,y+h, x,y, rr);
  ctx.arcTo(x,y, x+w,y, rr);
  ctx.closePath();
}
function hash01(str){
  // deterministic 0..1 from a string (same ninja always gets same wear)
  let h = 2166136261;
  for(let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return ((h >>> 0) % 10000) / 10000;
}

function shadeRGBA(hex, a=1){
  // "#rrggbb" -> "rgba(r,g,b,a)"
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return `rgba(${r},${g},${b},${a})`;
}
function drawMaskedNinja(n, v){
  const ctx = bctx;
  const dead = n.hp<=0;

  const fade = dead ? (1 - (v.koFade||0)) : 1;
  const flash = v.hitFlash || 0;
  const pulse = v.hpPulse || 0;

  ctx.save();
  ctx.globalAlpha = Math.max(0, fade);

  // shadow
  ctx.globalAlpha *= 0.55;
  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.beginPath();
  ctx.ellipse(v.x, v.y+28, 20, 6.5, 0, 0, Math.PI*2);
  ctx.fill();

  ctx.globalAlpha = Math.max(0, fade);

  // pulse scale
  const scale = 1 + pulse*0.12;
  ctx.translate(v.x, v.y);
  ctx.scale(scale, scale);

  // ---- belt + colors (FIXED ordering) ----
  const spent = tpSpent(n);
  const beltName = beltFromSpent(spent);

  // suit color: bosses purple, black-belts red, everyone else dark
  const suit = n.isBoss
    ? "rgba(90,20,120,.95)"       // purple boss
    : (beltName === "Black"
        ? "rgba(170,25,25,.95)"   // RED for Black Belt
        : "rgba(20,20,22,.95)");  // normal

  const trim = "rgba(255,255,255,.82)";
  const ink  = "rgba(0,0,0,.9)";

  // hit flash burst
  if(flash>0){
    ctx.fillStyle = `rgba(255,120,24,${0.32*flash})`;
    ctx.beginPath();
    ctx.arc(0, 0, 30, 0, Math.PI*2);
    ctx.fill();
  }

  // head (hood)
  ctx.fillStyle = suit;
  ctx.beginPath();
  ctx.arc(0,-20,12,0,Math.PI*2);
  ctx.fill();

  // face area (mask)
  ctx.fillStyle = "rgba(245,230,205,.95)";
  rr(ctx,-8,-26,16,12,6);
  ctx.fill();

  // mask band (covers lower face)
  ctx.fillStyle = suit;
  rr(ctx,-9,-20,18,10,5);
  ctx.fill();

  // eyes slit
  ctx.fillStyle = ink;
  rr(ctx,-7,-25,14,4,2);
  ctx.fill();
  ctx.fillStyle = "rgba(255,255,255,.65)";
  ctx.fillRect(-5,-24,4,2);
  ctx.fillRect( 1,-24,4,2);

  // body
  ctx.fillStyle = suit;
  rr(ctx,-13,-8,26,28,10);
  ctx.fill();

  // --- BELT (worn) ---
  const beltHex  = BELT_COLOR[beltName] || "#f5f5f5";

  // Belt position on the torso (matches your body box)
  const bx = -13, by = 6, bw = 26, bh = 6;

  // base belt fill
  ctx.fillStyle = shadeRGBA(beltHex, 0.95);
  rr(ctx, bx, by, bw, bh, 3);
  ctx.fill();

  // darker â€œfoldâ€ strip
  ctx.fillStyle = "rgba(0,0,0,.18)";
  rr(ctx, bx, by+2, bw, 2, 2);
  ctx.fill();

  // knot + tails (safe)
  const dirB = (v.side==="L") ? 1 : -1;

  // knot
  ctx.fillStyle = "rgba(0,0,0,.22)";
  rr(ctx, -2, by-1, 4, bh+2, 2);
  ctx.fill();

  // tail (always positive width)
  ctx.fillStyle = shadeRGBA(beltHex, 0.92);
  const tailW = 10;
  const tailX = (dirB === 1) ? 2 : (2 - tailW);
  rr(ctx, tailX, by+bh-1, tailW, 3, 2);
  ctx.fill();

  // wear: tiny scratches + faded specks (deterministic per ninja)
  const seed = hash01(n.id || n.name || "x");
  ctx.save();
  ctx.globalAlpha = 0.25 + seed*0.15;
  ctx.strokeStyle = "rgba(255,255,255,.65)";
  ctx.lineWidth = 1;
  for(let i=0;i<6;i++){
    const t = (seed*13 + i*0.21) % 1;
    const x = bx + 2 + t*(bw-4);
    const y = by + 1 + ((seed*7 + i*0.33) % 1)*(bh-2);
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + 3, y + 0.4);
    ctx.stroke();
  }
  ctx.globalAlpha = 0.18;
  ctx.fillStyle = "rgba(0,0,0,.45)";
  for(let i=0;i<5;i++){
    const t = (seed*19 + i*0.27) % 1;
    ctx.fillRect(bx + 2 + t*(bw-4), by + 1, 1, 1);
  }
  ctx.restore();
  // --- end belt ---

  // headband
  ctx.fillStyle = trim;
  rr(ctx,-12,-30,24,5,3);
  ctx.fill();

  // arms
  ctx.strokeStyle = suit;
  ctx.lineWidth = 5.5;
  ctx.lineCap = "round";
  const dir = v.side==="L" ? 1 : -1;
  ctx.beginPath(); ctx.moveTo(-10,-2); ctx.lineTo(-18*dir, 10); ctx.stroke();
  ctx.beginPath(); ctx.moveTo( 10,-2); ctx.lineTo( 18*dir, 10); ctx.stroke();

  // legs
  ctx.fillStyle = suit;
  rr(ctx,-11,18,9,10,5); ctx.fill();
  rr(ctx,  2,18,9,10,5); ctx.fill();

 // weapon (uses silhouette â€” dragon dagger looks special)
ctx.save();
ctx.translate(12*dir, 10);
ctx.scale(dir, 1);

// Swing rotation
const swingAmt = (v.swing || 0);
const swingDir = (v.swingDir || 1);

// Big visible arc: wind-up back then slash forward
const windUp = -0.9;   // radians
const slash  =  1.2;   // radians
const angle = (windUp + (slash - windUp) * easeInOut(swingAmt)) * swingDir;

// rotate around the hand
ctx.rotate(angle);

// Optional: little motion trail (simple + cheap)
if (swingAmt > 0.15) {
  ctx.globalAlpha = 0.12 + swingAmt * 0.25;
  ctx.strokeStyle = "rgba(255,255,255,.6)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(0, 0, 18, -0.8, 0.6);
  ctx.stroke();
  ctx.globalAlpha = 1;
}

drawWeaponSilhouette(ctx, equipBonus(n).weapon?.art || "");
ctx.restore();

  // name tag (boss marker)
  ctx.globalAlpha *= 0.95;
  ctx.fillStyle = "rgba(0,0,0,.75)";
  ctx.font = (n.isBoss ? "1000 11px system-ui" : "900 10px system-ui");
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText(n.isBoss ? "BOSS" : "", 0, -34);

  ctx.restore();

  // floating text
  if(v.floating?.length){
    for(const f of v.floating){
      const a = clamp(f.life/0.95, 0, 1);
      bctx.globalAlpha = a;
      bctx.font = f.crit ? "1000 16px system-ui" : "1000 14px system-ui";
      bctx.fillStyle = f.crit ? "rgba(255,120,24,.95)" : "rgba(255,255,255,.92)";
      bctx.textAlign = "center";
      bctx.textBaseline = "middle";
      bctx.fillText(f.text, f.x, f.y);
    }
    bctx.globalAlpha = 1;
  }
}

function drawBattle(){
  const ctx = bctx;
  ctx.clearRect(0,0,battleCanvas.width,battleCanvas.height);

  ctx.fillStyle = "rgba(0,0,0,.12)";
  ctx.fillRect(0,0,battleCanvas.width,battleCanvas.height);

  drawHealthStacks();

  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(battleCanvas.width/2, 90);
  ctx.lineTo(battleCanvas.width/2, battleCanvas.height-24);
  ctx.stroke();

  for(const n of battleState.your){
    const v = visFor(n);
    if(v) drawMaskedNinja(n,v);
  }
  for(const n of battleState.enemy){
    const v = visFor(n);
    if(v) drawMaskedNinja(n,v);
  }
}

/* ============================
   MAIN LOOP (never stops)
============================ */
function battleLoop(ts){
  if(!battleCanvas || !bctx){
    initBattleRenderer();
  }
  battleRAF = requestAnimationFrame(battleLoop);

  if(!battleState || !battleCanvas || !bctx) return;

  const t = ts/1000;
  const dt = clamp((t - (battleLastT||t)), 0, 0.05);
  battleLastT = t;

  // REAL auto pause/resume
  if(!battleState.over && battleAutoOn){
  stepDuels(dt);
}

  updateVisuals(dt);
  drawBattle();
}

/* ============================
   UI BINDINGS (overwrite-safe)
============================ */
(function bindBattleUI(){
  // Start RAF once
  initBattleRenderer();
  if(!battleRAF) battleRAF = requestAnimationFrame(battleLoop);

  const autoBtn = document.getElementById("battleAutoBtn");
  if(autoBtn){
    autoBtn.onclick = ()=>{
      if(!battleState || battleState.over) return;
      battleAutoOn = !battleAutoOn;
      renderBattleHUD();
    };
  }

  const retreatBtn = document.getElementById("battleRetreatBtn");
  if(retreatBtn){
    retreatBtn.onclick = ()=>leaveBattle();
  }

  const closeSel = document.getElementById("closeBattleSelect");
  if(closeSel){
    closeSel.onclick = ()=>closeModal("battleSelectModal");
  }
})();

/* ============================
   BATTLE SELECT MODAL
============================ */
function renderBattleSelect(){
  const list=document.getElementById("battleList");
  list.innerHTML="";

  const options=[
    {id:"easy",   name:"Scout Clan (Easy)",   desc:"Exactly 1 weak White Belt (1/1/1)."},
    {id:"medium", name:"Rival Clan (Medium)", desc:"Balanced clan size + stats."},
    {id:"hard",   name:"Elite Clan (Hard)",   desc:"Bigger clan + tougher stats."},
    {id:"boss",   name:"Boss Clan",           desc:"1 powerful Black Belt-style boss."},
  ];

  for(const o of options){
    const row=document.createElement("div");
    row.className="item";
    row.innerHTML=`
      <div>
        <div style="font-weight:1000">${o.name}</div>
        <div class="muted">${o.desc}</div>
      </div>
      <button class="btn primary small" data-battle="${o.id}">Fight</button>
    `;
    list.appendChild(row);
  }

  list.querySelectorAll("button[data-battle]").forEach(b=>{
    b.onclick=()=>{
      const kind=b.getAttribute("data-battle");
      closeModal("battleSelectModal");
      startBattle(kind);
    };
  });
}

/* ======================================================
   END BATTLE ENGINE REPLACEMENT
====================================================== */

/* ---------- Buildings ---------- */
$("hsHospital").onclick=()=>{
  const a=activeNinja(); recalc(a);
  // heal ALL ninjas at hospital (feels better with multi-ninja battles)
  for(const n of save.ninjas){ recalc(n); n.hp=n.maxHP; }
  persist(); refreshTop();
  alert("Healed your whole clan!");
};

$("hsDojo").onclick=()=>{
  setDojoTab("train");
  renderDojoTraining();
  renderDojoNinja();
  openModal("dojoModal");
  stopDojoPreviewAnim(); // ensures preview animation starts only on Ninja tab
};

$("hsDaimyo").onclick=()=>{
  renderDaimyo();
  openModal("daiModal");
};

$("hsRecruit").onclick=()=>{
  rosterSelectedId = save.activeId;
  renderRoster();
  openModal("recruitModal");
};

$("hsWeapon").onclick=()=>{
  ensureWeaponStock();
  weaponSelectedId = save.shop.weapons[0]?.id || null;
  renderWeaponShop();
  openModal("weaponModal");
};

$("hsRelic").onclick=()=>{
  ensureRelicStock();
  relicSelectedId = save.shop.relics[0]?.id || null;
  renderRelicShop();
  openModal("relicModal");
};

$("hsFight").onclick=()=>{
  renderBattleSelect();
  openModal("battleSelectModal");
};

/* ---------- Top buttons ---------- */
$("profilesBtn").onclick=()=>{
  renderProfiles();
  openModal("profilesModal");
};

    
/* ======================================================

====================================================== */
/* ======================================================
   PART 5 â€” INTEGRITY + FINAL BINDING + SAFETY GUARDS
   Fixes the missing ensureSaveIntegrity() + makes the file
   resilient if the script is re-pasted / re-run.
====================================================== */

/* ---------- Data integrity ---------- */
function ensureSaveIntegrity(){
  // profiles structure
  profiles = profiles || {active:"slot1", slots:{slot1:null,slot2:null,slot3:null}};
  profiles.active ||= "slot1";
  profiles.slots ||= {slot1:null,slot2:null,slot3:null};

  // active slot must exist
  if(!profiles.slots[profiles.active]) profiles.slots[profiles.active] = defaultSlot();
  save = profiles.slots[profiles.active];

  // save core structure
  save.currency ||= {gold:200, karma:50};
  save.currency.gold = Number(save.currency.gold||0);
  save.currency.karma = Number(save.currency.karma||0);

  save.daily ||= {lastClaim:0};
  save.daily.lastClaim = Number(save.daily.lastClaim||0);

  save.ninjas ||= [];
  if(!Array.isArray(save.ninjas)) save.ninjas = [];

  save.inventory ||= {weapons:[], relics:[]};
  save.inventory.weapons ||= [];
  save.inventory.relics ||= [];

  save.shop ||= {weapons:[], relics:[]};
  save.shop.weapons ||= [];
  save.shop.relics ||= [];

  save.meta ||= {wins:0, losses:0};
  save.meta.wins   = Number(save.meta.wins||0);
  save.meta.losses = Number(save.meta.losses||0);

  // ensure at least 1 ninja
  if(save.ninjas.length===0){
    const starter = makeNinja("Starter Ninja");
    starter.tp=10;
    recalc(starter);
    starter.hp=starter.maxHP;
    save.ninjas=[starter];
    save.activeId=starter.id;
  }

  // ensure activeId valid
  if(!save.activeId || !save.ninjas.some(n=>n.id===save.activeId)){
    save.activeId = save.ninjas[0].id;
  }

  // sanitize ninjas
  for(const n of save.ninjas){
    n.id ||= uid("n");
    n.name ||= "Ninja";
    n.tp = Number(n.tp||0);
    n.base ||= {str:1,agi:1,end:1};
    n.base.str = clamp(Number(n.base.str||1), 1, 999);
    n.base.agi = clamp(Number(n.base.agi||1), 1, 999);
    n.base.end = clamp(Number(n.base.end||1), 1, 999);
    n.equip ||= {weaponId:null, relicId:null};
    if(n.equip.weaponId === "") n.equip.weaponId = null;
    if(n.equip.relicId  === "") n.equip.relicId  = null;
    recalc(n);
    n.hp = clamp(Number(n.hp ?? n.maxHP), 0, n.maxHP);
  }

  // sanitize items
  const uniqById = (arr)=> {
    const seen=new Set();
    return arr.filter(x=>{
      if(!x || !x.id) return false;
      if(seen.has(x.id)) return false;
      seen.add(x.id);
      return true;
    });
  };
  save.inventory.weapons = uniqById(save.inventory.weapons);
  save.inventory.relics  = uniqById(save.inventory.relics);

  save.shop.weapons = uniqById(save.shop.weapons);
  save.shop.relics  = uniqById(save.shop.relics);

  // remove equips that point to missing items
  for(const n of save.ninjas){
    if(n.equip.weaponId && !save.inventory.weapons.some(w=>w.id===n.equip.weaponId)){
      n.equip.weaponId=null;
    }
    if(n.equip.relicId && !save.inventory.relics.some(r=>r.id===n.equip.relicId)){
      n.equip.relicId=null;
    }
    recalc(n);
    n.hp = clamp(n.hp, 0, n.maxHP);
  }
// enforce â€œweapon can only be equipped by one ninjaâ€ on load
{
  const seen = new Set();
  for (const n of save.ninjas) {
    const wid = n.equip?.weaponId;
    if (!wid) continue;

    if (seen.has(wid)) {
      n.equip.weaponId = null; // already taken
      recalc(n);
      n.hp = clamp(n.hp, 0, n.maxHP);
    } else {
      seen.add(wid);
    }
  }
}
  // persist back into profiles
  profiles.slots[profiles.active] = save;
}

/* ---------- One-time binding guard (prevents double onclick stacking) ---------- */
function bindOnce(id, evt, handler){
  const el = document.getElementById(id);
  if(!el) return;
  const key = `__bound_${evt}`;
  if(el[key]) return;
  el.addEventListener(evt, handler);
  el[key] = true;
}

/* ---------- Make sure battle loop exists even if battle opened later ---------- */
(function ensureBattleLoopRunning(){
  try{
    initBattleRenderer();
    if(!battleRAF) battleRAF = requestAnimationFrame(battleLoop);
  }catch(e){
    console.warn("Battle loop init skipped:", e);
  }
})();

/* ---------- Final safe init ---------- */
(function boot(){
  try{
    ensureSaveIntegrity();

    // seed shops if empty so opening modals never crashes
    ensureWeaponStock();
    ensureRelicStock();

    // refresh UI
    refreshTop();

    // OPTIONAL: if you want Dojo preview always correct when opening modal:
    // (keeps your current behavior; just ensures no crash if called early)
    if(document.getElementById("dojoCanvas")){
      try{ drawDojoPreview(); }catch{}
    }

    // Bind a couple â€œoften-missedâ€ ones safely (others already use .onclick)
    bindOnce("saveBtn","click",()=>{ try{ persist(); refreshTop(); alert("Saved!"); }catch(e){alert("Save error: "+(e?.message||e));} });
    bindOnce("resetBtn","click",()=>{
      try{
        profiles.slots[profiles.active]=defaultSlot();
        save=profiles.slots[profiles.active];
        ensureSaveIntegrity();
        persistProfiles();
        refreshTop();
        alert("Slot reset!");
      }catch(e){ alert("Reset error: "+(e?.message||e)); }
    });

  }catch(e){
    console.error(e);
    alert("Boot error: " + (e?.message||e));
  }
})();

/* ======================================================
   END PART 5
====================================================== */
</script>
</body>
</html>
